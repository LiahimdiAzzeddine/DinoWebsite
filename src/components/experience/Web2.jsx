/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/models/web3Ktx2.glb 
*/

import { useCallback, useContext, useEffect, useLayoutEffect, useRef, useState } from "react";
import { useThree } from "@react-three/fiber";
import { useGLTF, PerspectiveCamera, useAnimations } from "@react-three/drei";
import gsap from "gsap";
import { Observer } from "gsap/Observer";
import { ScrollTrigger } from "gsap/ScrollTrigger";
import * as THREE from "three";
import { AnimationContext } from "./AnimationContext";
import { ScrollToPlugin } from "gsap/ScrollToPlugin";

// Enregistrer les plugins
gsap.registerPlugin(ScrollTrigger, ScrollToPlugin, Observer);


export default function Web2({ sectionID, isActive, ...props }) {
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('./models/Model2.glb')
  const { actions, mixer } = useAnimations(animations, group)
  console.log("ðŸš€ ~ Web2 ~ actions:", actions)
  const { setCurrentModel } = useContext(AnimationContext);
  const currentTween = useRef(null);
  // handling screen width change
  const { viewport } = useThree()
  const viewportRef = useRef(viewport);

  const Animations = [
    "40M",
    "40MRope",
    "ArmatureMan",
    "BallonHotAirAction",
    "Balloon",
    "Balloon.001",
    "Balloon.002",
    "Emoji",
    "LeftHand",
    "RightHand",
  ];
  const smoothAnimations = ["Clouds1", "Clouds2"];

  let isTransitioning = false;
  let nextScrollTrigger = null;
  let prevScrollTrigger = null;
  let scrollDirection = -1;
  let velocityD = 0;
  let lastScrollTime = 0;

  const sceneContainerGroup = useRef();

  let disableOtherSections = () => {
    if (!prevScrollTrigger) {
      let currentScrollTrigger = ScrollTrigger.getById(sectionID);
      if (currentScrollTrigger && currentScrollTrigger.previous()) {
        prevScrollTrigger = currentScrollTrigger.previous();
        prevScrollTrigger.disable();
      }
    } else {
      prevScrollTrigger.disable();
    }

    if (!nextScrollTrigger) {
      let currentScrollTrigger = ScrollTrigger.getById(sectionID);
      if (currentScrollTrigger && currentScrollTrigger.next()) {
        nextScrollTrigger = currentScrollTrigger.next();
        nextScrollTrigger.disable();
      }
    } else {
      nextScrollTrigger.disable();
    }
  }

  let enterAnim = actions["UP"];
  let leaveAnim = actions["DOWN"];
  let sceneDefaultPos = 0;



  useEffect(() => {
    viewportRef.current = viewport;
  }, [viewport]);

  useEffect(() => {
    const target = document.documentElement;
    const observer = Observer.create({
      target,
      type: "wheel,touch,pointer,scroll",
      onChange: (obs) => {
        scrollDirection = obs.deltaY > 0 ? 1 : -1;
        velocityD = Math.abs(obs.velocityY);
      },
      //preventDefault: true,
    });
    return () => observer.kill();
  }, []);

  let playStaticAnimations = () => {
    Animations.forEach((name) => {
      actions[name]?.reset().play();
    });

    smoothAnimations.forEach((name) => {
      actions[name]?.reset().setEffectiveTimeScale(0.2).play();
    });
  }
  useEffect(() => {
    const mediaQuery = window.matchMedia("(max-width: 767px)");
    const handleChange = (e) => setIsMobile(e.matches);
    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, []);

  const enableNextSection = () => {
    if (nextScrollTrigger) {

      nextScrollTrigger.enable();
    }
  };

  const enablePrevSection = () => {
    if (prevScrollTrigger) {
      prevScrollTrigger.enable();
    }
  };
const playActionOnce = (actionName, sectionID, scrollSpeed = 1, onFinishCallback = () => {}) => {
  if (isTransitioning) return;

  const action = actions[actionName];
  if (!action) return;

  // Animation des nuages liÃ©e
  const cloudActionName = `Clouds_${actionName}`;
  const cloudAction = actions[cloudActionName];

  // Liste des animations concernÃ©es
  const animationNames = ["UP", "UP2", "DOWN", "DOWN2"];

  // Stopper uniquement les animations opposÃ©es
  animationNames.forEach((name) => {
    if (name !== actionName && actions[name]) {
      actions[name].stop();
    }
    const cloudName = `Clouds_${name}`;
    if (cloudName !== cloudActionName && actions[cloudName]) {
      actions[cloudName].stop();
    }
  });

  isTransitioning = true;

  // PrÃ©paration de l'action principale
  action.reset().setLoop(THREE.LoopOnce, 1);
  action.clampWhenFinished = true;
  action.time = 0;

  // PrÃ©paration de l'action de nuages si elle existe
  if (cloudAction) {
    cloudAction.reset().setLoop(THREE.LoopOnce, 1);
    cloudAction.clampWhenFinished = true;
    cloudAction.time = 0;
  }

  const minSpeed =2;
  const maxSpeed = 5;
  const scale = Math.min(Math.max(scrollSpeed / 1000, minSpeed), maxSpeed);
  console.log("ðŸš€ ~ playActionOnce ~ scale:", scale);

  // Appliquer easing Ã  l'action principale
  action.timeScale = 0.01;
  gsap.to(action, {
    timeScale: scale,
    duration: 0.1,
    ease: "slow(0.7,0.7,false)",
  });

  // Appliquer easing Ã  l'action de nuages si elle existe
  if (cloudAction) {
    cloudAction.timeScale = 0.5;
    gsap.to(cloudAction, {
      timeScale: scale,
      duration: 0.1,
      ease: "slow(0.7,0.7,false)",
    });
  }

  // Supprimer tous les anciens listeners
  if (mixer && mixer._listeners && mixer._listeners.finished) {
    mixer._listeners.finished = [];
  }

  const onMixerFinished = (e) => {
    if (e.action === action) {
      mixer.removeEventListener('finished', onMixerFinished);
      isTransitioning = false;
      onFinishCallback();
    }
  };

  mixer.addEventListener('finished', onMixerFinished);

  // Lancer les deux actions
  action.play();
  if (cloudAction) cloudAction.play();
};

  const detectFastScroll = useCallback((velocity, observerVelocity) => {
    const currentTime = Date.now();
    const timeDiff = currentTime - lastScrollTime;
    lastScrollTime = currentTime;

    // ConsidÃ©rer comme rapide si vÃ©locitÃ© ScrollTrigger > 2000 OU vÃ©locitÃ© Observer > 10000
    const isFastByVelocity = Math.abs(velocity) > 2000 || Math.abs(observerVelocity) > 10000 || velocity == 0 || observerVelocity == 0;
    const isFastByTime = timeDiff < 16;

    console.log('DetectFastScroll:', {
      velocity,
      observerVelocity,
      timeDiff,
      isFastByVelocity,
      isFastByTime
    });

    return isFastByVelocity || isFastByTime;
  }, []);

  useLayoutEffect(() => {
    sceneDefaultPos = sceneContainerGroup.current.position.y;
    enterAnim = actions["UP"];
    leaveAnim = actions["DOWN"];
    const mm = gsap.matchMedia();

    mm.add("(min-width: 768px)", () => {
      const trigger = ScrollTrigger.create({
        id: sectionID,
        trigger: "#section3",
        start: "center+=100 bottom",
        end: "center+=200 top",
        scrub: true,
        markers: false,
        onToggle: ({ isActive }) => {
          if (isActive) {
            disableOtherSections();
            playStaticAnimations();
            setCurrentModel(sectionID);

            if (scrollDirection === 1) {
              playActionOnce("UP", sectionID, velocityD, () => {
                enableNextSection();
              });
            } else {
              ScrollTrigger.getById('web2')?.enable();
              playActionOnce("DOWN2", sectionID, velocityD, () => {
                enablePrevSection();
              });
            }
          } else {
            if (scrollDirection === 1) {
              // Sortie vers le bas


            } else {
              ScrollTrigger.getById('web1')?.disable();
              // Sortie vers le haut
              playActionOnce("DOWN", sectionID, velocityD, () => {
                enablePrevSection();
              });

            }
          }
        },



        onLeaveBack: () => {
          console.log(`${sectionID} onLeaveBack`);
          const web1Trigger = ScrollTrigger.getById('web1');
          if (web1Trigger) web1Trigger.disable();
        },

        onEnterBack: () => {
          console.log(`${sectionID} onEnterBack`);
          const web2Trigger = ScrollTrigger.getById('web2');
          if (web2Trigger) web2Trigger.enable();
        },

        onLeave: ({ isActive, getVelocity }) => {
          const currentVelocity = getVelocity();
          const isFastScroll = detectFastScroll(currentVelocity, velocityD);

          console.log("onLeave:", {
            scrollDirection,
            velocityD,
            currentVelocity,
            isFastScroll,
            isActive
          });

          // Conditions pour activer web3
          const shouldActivateWeb3 = isFastScroll || Math.abs(currentVelocity) > 2000 || velocityD > 10000;

          if (shouldActivateWeb3) {
            // Scroll rapide ou clic sur bouton - transition directe vers web3
            console.log("ðŸš€ Activation directe de web3");
            setCurrentModel("web3");
            const web3Trigger = ScrollTrigger.getById('web3');
            if (web3Trigger) web3Trigger.enable();

            // Forcer l'activation si on est en direction descendante
            if (scrollDirection === 1) {
              playActionOnce("UP2", scrollDirection, velocityD, () => {
                enableNextSection();
              });
            }
          } else {
            // Scroll normal
            console.log("ðŸš€ Scroll normal - gestion standard");
            const web3Trigger = ScrollTrigger.getById('web3');
            if (web3Trigger) web3Trigger.disable();

            if (scrollDirection === 1 && !isActive) {
              playActionOnce("UP2", scrollDirection, velocityD, () => {
                enableNextSection();
                setCurrentModel("web3");
                const web3TriggerAfter = ScrollTrigger.getById('web3');
                if (web3TriggerAfter) web3TriggerAfter.enable();
              });
            }
          }
        }
      });


      return () => trigger.kill();
    });

    // âœ… Mobile only (tu peux mettre autre comportement ici si besoin)
    mm.add("(max-width: 767px)", () => {
      // Ajustement mobile initial (si nÃ©cessaire)
      //sceneContainerGroup.current.position.y -= 0.4;
      // Valeurs de rÃ©fÃ©rence pour animation
      const sceneDefaultPos = sceneContainerGroup.current.position.y;
      const minY = -0.20;
      const maxY = sceneDefaultPos + 2; // ajuste selon la distance souhaitÃ©e
      let initialProgress = 0;
      const trigger = ScrollTrigger.create({
        id: sectionID + "-mobile",
        trigger: "#section3",
        start: "top bottom+=275",
        end: "bottom top",
        scrub: true,
        markers: false,
        preventClicks: true,
        onEnter: (self) => {
          if (initialProgress == 0) {
            initialProgress = self.progress;
          }
        },
        onUpdate: (self) => {
          if (initialProgress == 0) {
            initialProgress = self.progress;
          }
          const progress = self.progress - initialProgress;
          const newY = THREE.MathUtils.lerp(minY, maxY, progress);

          if (currentTween.current) currentTween.current.kill();

          currentTween.current = gsap.to(sceneContainerGroup.current.position, {
            y: newY,
            duration: 0.3,
            ease: "sine.out",
            overwrite: true
          });
        },
        onToggle: ({ isActive }) => {
          if (isActive) {
            disableOtherSections();
            playStaticAnimations();
            setCurrentModel(sectionID);

            if (scrollDirection === 1) {
              //playActionOnce("UP", sectionID, velocityD);
              playActionOnce("UP", sectionID, velocityD, () => {
                enableNextSection();
              });
            } else {
              // playActionOnce("DOWN2", sectionID, velocityD);
              playActionOnce("DOWN2", sectionID, velocityD, () => {
                enablePrevSection();
              });
            }
          } else {
            if (scrollDirection === 1) {
              // Sortie vers le bas
              playActionOnce("UP2", sectionID, velocityD, () => {
                enableNextSection();
              });
            } else {
              // Sortie vers le haut
              playActionOnce("DOWN", sectionID, velocityD, () => {
                enablePrevSection();
              });

            }
          }
        },

      });

      return () => trigger.kill();
    });

    return () => mm.revert();
  }, []);

  return (
    <group ref={group} {...props} dispose={null} visible={isActive}>
      <group name="Scene">
        <group name="CamMove" position={[23.142, 20.042, 1.408]} scale={0.15}>
          <PerspectiveCamera
            name="Camera"
            makeDefault={false}
            far={1000}
            near={0.1}
            fov={16.696}
            position={[0, 0.151, 0.577]}
            rotation={[0, 1.571, 0]}
            scale={6.678}
          />
        </group>
        <group name="All" position={[0, 10.276, 0]} scale={6.534} >
          <group ref={sceneContainerGroup} name="scene_container"
            scale={viewport.width < 5 ? 0.7 : 1}
            // position-x={viewport.width < 5 ? 2.5 : 0}
            position-z={viewport.width < 5 ? 0.23 : 0}
            position-y={viewport.width < 5 ? -0.19 : 0}
          >
            <group
            name="Armature001"
            position={[-0.014, 0.129, -0.036]}
            rotation={[0.077, 1.536, -0.317]}
            scale={0.051}>
            <group name="Retopo_Sphere001">
              <skinnedMesh
                name="mesh001"
                geometry={nodes.mesh001.geometry}
                material={materials['Material.016']}
                skeleton={nodes.mesh001.skeleton}
              />
              <skinnedMesh
                name="mesh001_1"
                geometry={nodes.mesh001_1.geometry}
                material={materials.pants}
                skeleton={nodes.mesh001_1.skeleton}
              />
              <skinnedMesh
                name="mesh001_2"
                geometry={nodes.mesh001_2.geometry}
                material={materials.skin}
                skeleton={nodes.mesh001_2.skeleton}
              />
            </group>
            <primitive object={nodes.Bone} />
            <primitive object={nodes.Bone007} />
            <primitive object={nodes.Bone008} />
          </group>
            <group
              name="BallonHotAir"
              position={[-2.232, 0.699, 0.379]}
              rotation={[0.007, -0.012, -0.001]}
              scale={0.106}>
              <mesh
                name="Sphere010"
                castShadow
                receiveShadow
                geometry={nodes.Sphere010.geometry}
                material={materials['Material.007']}
              />
              <mesh
                name="Sphere010_1"
                castShadow
                receiveShadow
                geometry={nodes.Sphere010_1.geometry}
                material={materials['Material.005']}
              />
              <mesh
                name="Sphere010_2"
                castShadow
                receiveShadow
                geometry={nodes.Sphere010_2.geometry}
                material={materials['Material.010']}
              />
              <mesh
                name="Sphere010_3"
                castShadow
                receiveShadow
                geometry={nodes.Sphere010_3.geometry}
                material={materials['Material.009']}
              />
              <mesh
                name="Sphere010_4"
                castShadow
                receiveShadow
                geometry={nodes.Sphere010_4.geometry}
                material={materials['Material.011']}
              />
              <mesh
                name="Sphere010_5"
                castShadow
                receiveShadow
                geometry={nodes.Sphere010_5.geometry}
                material={materials['Material.013']}
              />
              <mesh
                name="Sphere010_6"
                castShadow
                receiveShadow
                geometry={nodes.Sphere010_6.geometry}
                material={materials['Material.012']}
              />
            </group>
            <group
              name="Cube043_Cube001"
              position={[0.321, -1.207, 0.607]}
              rotation={[Math.PI / 2, 0, 0]}
              scale={0.153}>
              <mesh
                name="Cube043_Cube001_1"
                castShadow
                receiveShadow
                geometry={nodes.Cube043_Cube001_1.geometry}
                material={materials['Orange.001']}
              />
              <mesh
                name="Cube043_Cube001_2"
                castShadow
                receiveShadow
                geometry={nodes.Cube043_Cube001_2.geometry}
                material={materials['Material.006']}
              />
            </group>
            <group
              name="Cube043_Cube053"
              position={[0.352, -0.883, -0.3]}
              rotation={[Math.PI / 2, 0, 0]}
              scale={0.153}>
              <mesh
                name="Cube043_Cube053_1"
                castShadow
                receiveShadow
                geometry={nodes.Cube043_Cube053_1.geometry}
                material={materials.Orange}
              />
              <mesh
                name="Cube043_Cube053_2"
                castShadow
                receiveShadow
                geometry={nodes.Cube043_Cube053_2.geometry}
                material={materials['Material.006']}
              />
            </group>
            <group
              name="Cube044_Cube054"
              position={[-1.019, -0.625, 0.125]}
              rotation={[Math.PI / 2, 0, -1.594]}
              scale={0.153}>
              <mesh
                name="Cube044_Cube054_1"
                castShadow
                receiveShadow
                geometry={nodes.Cube044_Cube054_1.geometry}
                material={materials.blue}
              />
              <mesh
                name="Cube044_Cube054_2"
                castShadow
                receiveShadow
                geometry={nodes.Cube044_Cube054_2.geometry}
                material={materials['Material.006']}
              />
            </group>
            <group
              name="Empty005"
              position={[0.001, 0.259, -0.089]}
              rotation={[1.528, 1.519, -0.667]}
              scale={0.16}>
              <group
                name="Trophy"
                position={[0.357, -0.012, 0.013]}
                rotation={[1.425, -1.328, 1.432]}
                scale={0.955}>
                <mesh
                  name="Cylinder009"
                  castShadow
                  receiveShadow
                  geometry={nodes.Cylinder009.geometry}
                  material={materials.M_Tropy}
                />
                <mesh
                  name="Cylinder009_1"
                  castShadow
                  receiveShadow
                  geometry={nodes.Cylinder009_1.geometry}
                  material={materials['Material.008']}
                />
                <mesh
                  name="Cylinder009_2"
                  castShadow
                  receiveShadow
                  geometry={nodes.Cylinder009_2.geometry}
                  material={materials.Material}
                />
              </group>
            </group>
            <group
              name="Empty006"
              position={[-0.011, 0.279, 0.028]}
              rotation={[0.831, 1.513, -0.007]}
              scale={0.041}>
                 <group
              name="Armature"
              position={[0.239, 0.054, 0.33]}
              rotation={[1.601, 0.618, 1.507]}
              scale={3.568}>
              <skinnedMesh
                name="Cube"
                geometry={nodes.Cube.geometry}
                material={materials.Blackk}
                skeleton={nodes.Cube.skeleton}
              />
              <primitive object={nodes.Bone_1} />
            </group>
              <mesh
                name="Cube001"
                castShadow
                receiveShadow
                geometry={nodes.Cube001.geometry}
                material={materials.skin}
                position={[-0.12, -0.118, 0.312]}
                rotation={[-1.58, 0.644, 1.602]}
                scale={3.568}
              />
              <mesh
                name="Cube008"
                castShadow
                receiveShadow
                geometry={nodes.Cube008.geometry}
                material={materials.skin}
                position={[0.136, -0.126, 0.306]}
                rotation={[1.611, 1.033, -1.617]}
                scale={3.568}
              />
              <group
                name="Cube011"
                position={[0.321, 0.089, 0.383]}
                rotation={[1.581, 0.176, -1.628]}
                scale={[0.076, 2.381, 0.076]}>
                <mesh
                  name="Cube019"
                  castShadow
                  receiveShadow
                  geometry={nodes.Cube019.geometry}
                  material={materials.Blackk}
                />
                <mesh
                  name="Cube019_1"
                  castShadow
                  receiveShadow
                  geometry={nodes.Cube019_1.geometry}
                  material={materials['Material.008']}
                />
              </group>
             
            </group>
           
            <mesh
              name="Sphere002"
              castShadow
              receiveShadow
              geometry={nodes.Sphere002.geometry}
              material={materials['Material.001']}
              position={[-0.033, -0.041, -0.554]}
              rotation={[-0.413, 0.743, 0.652]}
              scale={0.104}>
              <group
                name="glasss2"
                position={[0.003, 0.084, 1.035]}
                rotation={[1.706, -0.077, -0.068]}
                scale={0.241}>
                <mesh
                  name="Mesh006"
                  castShadow
                  receiveShadow
                  geometry={nodes.Mesh006.geometry}
                  material={materials.glass_mat}
                />
                <mesh
                  name="Mesh006_1"
                  castShadow
                  receiveShadow
                  geometry={nodes.Mesh006_1.geometry}
                  material={materials.Glass_shader_out}
                />
              </group>
              <mesh
                name="Mouth_Cube002"
                castShadow
                receiveShadow
                geometry={nodes.Mouth_Cube002.geometry}
                material={materials.Eye_Lid}
                position={[-0.001, -0.532, 0.853]}
                rotation={[Math.PI / 2, 0, 0]}
                scale={0.43}
              />
            </mesh>
           
          
          </group>
        </group>
        <PerspectiveCamera
          name="BlockedCam"
          makeDefault={isActive}
          far={1000}
          near={0.1}
          fov={16.696}
          position={[23.089, 1.705, 1.436]}
          rotation={[0, 1.571, 0]}
        />
         <group name="Cloudes" position={[0, 16.072, 0]} scale={6.534}>
          <mesh
            name="Sphere001"
            castShadow
            receiveShadow
            geometry={nodes.Sphere001.geometry}
            material={nodes.Sphere001.material}
            position={[-0.267, 0.905, 0.147]}
            rotation={[Math.PI, 0, Math.PI]}
            scale={[0.033, 0.056, 0.056]}
          />
          <mesh
            name="Sphere014"
            castShadow
            receiveShadow
            geometry={nodes.Sphere014.geometry}
            material={nodes.Sphere014.material}
            position={[-0.267, 0.297, -0.209]}
            scale={[0.033, 0.056, 0.056]}
          />
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('./models/Model2.glb')