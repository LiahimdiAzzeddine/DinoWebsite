/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/models/Web2.glb 
*/

import React, {useContext, useEffect, useLayoutEffect, useRef} from "react";
import {useGraph, useThree} from "@react-three/fiber";
import {useGLTF, PerspectiveCamera, useAnimations, Scroll} from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import gsap from "gsap";
import {Observer} from "gsap/Observer";
import { ScrollTrigger } from "gsap/ScrollTrigger";
import * as THREE from "three";
import { AnimationContext } from "./AnimationContext";

export function Web2({sectionID, isActive, ...props }) {
  const group = React.useRef();
  const { scene, animations } = useGLTF("./models/web2Webp.glb");
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);
  const { actions, mixer } = useAnimations(animations, group);
  const clock = new THREE.Clock();

  const { currentModel, setCurrentModel, isTransitioning, setIsTransitioning } =
    useContext(AnimationContext);
  const Animations = [
    "40M",
    "40MRope",
    "ArmatureMan",
    "BallonHotAirAction",
    "Balloon",
    "Balloon.001",
    "Balloon.002",
    "Emoji",
    "LeftHand",
    "RightHand",
  ];
  const smoothAnimations = ["Clouds1", "Clouds2"];

  // scroll tracking
  let nextScrollTrigger = null;
  let prevScrollTrigger = null;
  let scrollDirection = 1;
  const sceneContainerGroup = useRef();
  let disableOtherSections = ()=>{
    if (!prevScrollTrigger){
      let currentScrollTrigger = ScrollTrigger.getById(sectionID);
      if (currentScrollTrigger && currentScrollTrigger.previous()) {
        prevScrollTrigger = currentScrollTrigger.previous();
        prevScrollTrigger.disable();
      }
    }else{
      prevScrollTrigger.disable();
    }

    if (!nextScrollTrigger){
      let currentScrollTrigger = ScrollTrigger.getById(sectionID);
      if (currentScrollTrigger && currentScrollTrigger.next()) {
        nextScrollTrigger = currentScrollTrigger.next();
        nextScrollTrigger.disable();
      }
    }else{
      nextScrollTrigger.disable();
    }
  }

  let enableOtherSections = ()=>{
    // use when scroll is too quick for transitions
    // this way any section t the end of the scroll could take control and disable the others
    ScrollTrigger.getAll().forEach((trigger) => {
      if (trigger.id !== sectionID) {
        trigger.enable();
      }
    })
  }

  let enterAnim = actions["ActionEnter"];
  let leaveAnim = actions["ActionOut"];
  let sceneDefaultPos = 0;

  // handling screen width change
  const { viewport } = useThree()
  const viewportRef = useRef(viewport);
  useEffect(() => {
    viewportRef.current = viewport;
  }, [viewport]);

  useLayoutEffect(() => {

    enterAnim = actions["ActionEnter"];
    leaveAnim = actions["ActionOut"];
    sceneDefaultPos = sceneContainerGroup.current.position.y;

    // scroll tracking
    Observer.create({
      target: window,
      type: "wheel,touch,pointer,scroll",
      onChange: obs => {
        // obs.deltaY < 0 means scrolling up, > 0 means down
        // console.log(obs.deltaY < 0 ? "raw ↑" : "raw ↓");
        scrollDirection = obs.deltaY < 0 ? -1 : 1;
      }
    });

    ScrollTrigger.create({
      id: sectionID,
      trigger: "#section3",
      start: "top bottom",
      end: "top top",
      scrub: true,
      markers: false,
      preventClicks: true,
      onToggle: self => {
        if (self.isActive) {
          disableOtherSections();
          playStaticAnimations();
          setCurrentModel(sectionID);

          // direction: +1 means scrolling forward/down, –1 is backward/up
          if (scrollDirection >= 0) {
            // onEnter
            if (enterAnim) {
              enterAnim.reset().setLoop(THREE.LoopOnce, 1);
              enterAnim.clampWhenFinished = true;
              enterAnim.time = 0;
              enterAnim.timeScale = 1;
              enterAnim.play();
            }
            gsap.to(sceneContainerGroup.current.position, {
              y: sceneDefaultPos,
              duration: leaveAnim.getClip().duration,
              ease:"back.out"
            });
          } else {
            // onEnterBack
            playOnEnterBackSequence();

          }
        } else {
          if (scrollDirection >= 0) {
            // onLeave
            handleOnLeave(self);
          }
        }
      },
      onLeaveBack: (self) => {
        if (Math.abs(self.getVelocity()) <= 2000) {
          // Reset & configure the action so that it plays backwards exactly once:
          enterAnim.reset();
          enterAnim.setLoop(THREE.LoopOnce, 1);
          enterAnim.clampWhenFinished = true;
          enterAnim.time = enterAnim.getClip().duration;     // jump to the very end of the clip
          enterAnim.timeScale = -1.5;

          // one-time callback for when this action actually finishes:
          const onActionFinished = (event) => {
            // event.action is the AnimationAction that just finished
            if (event.action === enterAnim) {
              // Remove listener so it only fires once
              enterAnim.getMixer().removeEventListener("finished", onActionFinished);
              prevScrollTrigger.enable();
            }
          };

          // Add the listener and start playing:
          enterAnim.getMixer().addEventListener("finished", onActionFinished);
          enterAnim.play();
        }else{
          enableOtherSections();
        }

      }
    });


    return () => {
      // Clean up
      mixer.stopAllAction();
    };
  }, []);

  let playOnEnterBackSequence = ()=>{
    if (leaveAnim) {
      leaveAnim.reset();
      leaveAnim.setLoop(THREE.LoopOnce, 1);
      leaveAnim.time = leaveAnim.getClip().duration;
      leaveAnim.timeScale = -1;
      leaveAnim.clampWhenFinished = true;
      leaveAnim.play();
    }
    gsap.to(sceneContainerGroup.current.position, {
      y: sceneDefaultPos,
      duration: leaveAnim.getClip().duration,
      ease:"back.out"
    });
  }

  let playStaticAnimations = ()=>{
    Animations.forEach((name) => {
      actions[name]?.reset().play();
    });

    smoothAnimations.forEach((name) => {
      actions[name]?.reset().setEffectiveTimeScale(0.2).play();
    });
  }

  let handleOnLeave = (self)=>{
    if (Math.abs(self.getVelocity()) <= 4000) {
      nextScrollTrigger.disable();
      // Reset & configure the action
      leaveAnim.reset().setLoop(THREE.LoopOnce, 1);
      leaveAnim.clampWhenFinished = true;
      leaveAnim.timeScale = 1;

      gsap.to(sceneContainerGroup.current.position, {
        y: sceneDefaultPos + 10,
        duration: leaveAnim.getClip().duration ,
        ease:"back.in"
      });

      setTimeout(() => {
        nextScrollTrigger.enable();
      }, leaveAnim.getClip().duration * 1000 * leaveAnim.timeScale);
      leaveAnim.play();
    }else{
      enableOtherSections();
    }
  }

  return (
    <group ref={group} {...props} dispose={null} visible={isActive}>
      <group name="Scene">
        <group name="Sphere014" position={[-3.668, 4.08, -2.876]} scale={[0.45, 0.767, 0.767]}>
          <mesh
            name="Sphere025"
            castShadow
            receiveShadow
            geometry={nodes.Sphere025.geometry}
            material={nodes.Sphere025.material}
            position={[-5.925, -4.271, 4.499]}
            scale={19.371}
          />
        </group>
        <group
          name="Sphere001"
          position={[-3.668, 12.438, 2.018]}
          rotation={[Math.PI, 0, Math.PI]}
          scale={[0.45, 0.767, 0.767]}>
          <mesh
            name="Sphere030"
            castShadow
            receiveShadow
            geometry={nodes.Sphere030.geometry}
            material={nodes.Sphere030.material}
            position={[1.804, -2.964, 1.659]}
            scale={17.436}
          />
        </group>
        <group name="Empty001" position={[23.142, 1.679, 1.408]} scale={0.15}>
          <PerspectiveCamera
              name="Camera"
              makeDefault={isActive}
              far={1000}
              near={0.1}
              fov={16.696}
              position={[0, 0.151, 0.577]}
              rotation={[0, 1.571, 0]}
              scale={6.678}
          />
        </group>
          <group ref={sceneContainerGroup} name="scene_container"
               scale={viewport.width < 5 ? 0.7 : 1}
               // position-x={viewport.width < 5 ? 2.5 : 0}
               position-z={viewport.width < 5 ? 1.5 : 0}
               position-y={viewport.width < 5 ? 0.3 : 0}
        >

        <mesh
          name="Sphere002"
          castShadow
          receiveShadow
          geometry={nodes.Sphere002.geometry}
          material={materials.PaletteMaterial001}
          position={[-0.174, -0.249, -3.579]}
          rotation={[-0.413, 0.743, 0.652]}
          scale={0.737}
        />
        <group
          name="BallonHotAir"
          position={[-14.582, 4.564, 2.476]}
          rotation={[0.007, -0.012, -0.001]}
          scale={0.694}>
          <group position={[0, -0.349, 0]} scale={1.833}>
            <mesh
              name="Sphere010"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010.geometry}
              material={materials.PaletteMaterial001}
            />
            <mesh
              name="Sphere010_1"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010_1.geometry}
              material={materials.PaletteMaterial001}
            />
            <mesh
              name="Sphere010_2"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010_2.geometry}
              material={materials.PaletteMaterial001}
            />
            <mesh
              name="Sphere010_3"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010_3.geometry}
              material={materials.PaletteMaterial001}
            />
            <mesh
              name="Sphere010_4"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010_4.geometry}
              material={materials.PaletteMaterial001}
            />
            <mesh
              name="Sphere010_5"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010_5.geometry}
              material={materials.PaletteMaterial001}
            />
            <mesh
              name="Sphere010_6"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010_6.geometry}
              material={materials.PaletteMaterial001}
            />
          </group>
        </group>
        <group
          name="Cube043_Cube053"
          position={[2.297, -5.768, -1.96]}
          rotation={[Math.PI / 2, 0, 0]}>
          <group scale={1.344}>
            <mesh
              name="Cube043_Cube053_1"
              castShadow
              receiveShadow
              geometry={nodes.Cube043_Cube053_1.geometry}
              material={materials.PaletteMaterial003}
            />
            <mesh
              name="Cube043_Cube053_2"
              castShadow
              receiveShadow
              geometry={nodes.Cube043_Cube053_2.geometry}
              material={materials.PaletteMaterial001}
            />
          </group>
        </group>
        <group
          name="Cube044_Cube054"
          position={[-6.655, -4.081, 0.819]}
          rotation={[Math.PI / 2, 0, -1.594]}>
          <group scale={1.224}>
            <mesh
              name="Cube044_Cube054_1"
              castShadow
              receiveShadow
              geometry={nodes.Cube044_Cube054_1.geometry}
              material={materials.PaletteMaterial003}
            />
            <mesh
              name="Cube044_Cube054_2"
              castShadow
              receiveShadow
              geometry={nodes.Cube044_Cube054_2.geometry}
              material={materials.PaletteMaterial001}
            />
          </group>
        </group>
        <group
          name="Cube043_Cube001"
          position={[2.099, -7.888, 3.968]}
          rotation={[Math.PI / 2, 0, 0]}>
          <group scale={1.344}>
            <mesh
              name="Cube043_Cube001_1"
              castShadow
              receiveShadow
              geometry={nodes.Cube043_Cube001_1.geometry}
              material={materials.PaletteMaterial003}
            />
            <mesh
              name="Cube043_Cube001_2"
              castShadow
              receiveShadow
              geometry={nodes.Cube043_Cube001_2.geometry}
              material={materials.PaletteMaterial001}
            />
          </group>
        </group>
        <group
          name="Armature001"
          position={[-0.091, 0.84, -0.237]}
          rotation={[0.077, 1.536, -0.317]}
          scale={0.336}>
          <primitive object={nodes.Bone} />
          <primitive object={nodes.Bone007} />
          <primitive object={nodes.Bone008} />
        </group>
        <group
          name="Empty005"
          position={[0.004, 1.693, -0.583]}
          rotation={[1.528, 1.519, -0.667]}
          scale={1.047}>
          <mesh
            name="Trophy"
            castShadow
            receiveShadow
            geometry={nodes.Trophy.geometry}
            material={materials.PaletteMaterial001}
            position={[0.326, -0.008, 0.014]}
            rotation={[1.425, -1.328, 1.432]}
            scale={0.509}
          />
        </group>
        <group
          name="Empty006"
          position={[-0.072, 1.82, 0.182]}
          rotation={[0.831, 1.513, -0.007]}
          scale={0.268}>
          <group
            name="Armature"
            position={[0.239, 0.054, 0.33]}
            rotation={[1.601, 0.618, 1.507]}
            scale={3.568}>
            <skinnedMesh
              name="Cube"
              geometry={nodes.Cube.geometry}
              material={materials.PaletteMaterial001}
              skeleton={nodes.Cube.skeleton}
            />
            <primitive object={nodes.Bone_1} />
          </group>
          <mesh
            name="Cube001"
            castShadow
            receiveShadow
            geometry={nodes.Cube001.geometry}
            material={materials.PaletteMaterial001}
            position={[-0.031, -0.172, 0.31]}
            rotation={[-1.58, 0.644, 1.602]}
            scale={0.335}
          />
          <group
            name="Cube011"
            position={[0.321, 0.089, 0.383]}
            rotation={[1.581, 0.176, -1.628]}
            scale={[0.076, 2.381, 0.076]}>
            <group position={[-0.563, 1.854, -20.444]} scale={73.785}>
              <mesh
                name="Cube019"
                castShadow
                receiveShadow
                geometry={nodes.Cube019.geometry}
                material={materials.PaletteMaterial001}
              />
              <mesh
                name="Cube019_1"
                castShadow
                receiveShadow
                geometry={nodes.Cube019_1.geometry}
                material={materials.PaletteMaterial001}
              />
            </group>
          </group>
        </group>
        <mesh
          name="Mouth_Cube002"
          castShadow
          receiveShadow
          geometry={nodes.Mouth_Cube002.geometry}
          material={materials.PaletteMaterial002}
          position={[0.341, -0.418, -3.247]}
          rotation={[1.635, 0.463, -0.857]}
          scale={0.223}
        />
        <group
          name="Retopo_Sphere001"
          position={[-0.091, 0.84, -0.237]}
          rotation={[0.077, 1.536, -0.317]}
          scale={0.336}>
          <skinnedMesh
            name="mesh001"
            geometry={nodes.mesh001.geometry}
            material={materials.PaletteMaterial001}
            skeleton={nodes.mesh001.skeleton}
          />
          <skinnedMesh
            name="mesh001_1"
            geometry={nodes.mesh001_1.geometry}
            material={materials.PaletteMaterial001}
            skeleton={nodes.mesh001_1.skeleton}
          />
          <skinnedMesh
            name="mesh001_2"
            geometry={nodes.mesh001_2.geometry}
            material={materials.PaletteMaterial001}
            skeleton={nodes.mesh001_2.skeleton}
          />
        </group>
</group>

      </group>
    </group>





  );
}

useGLTF.preload("./models/web2Webp.glb");
