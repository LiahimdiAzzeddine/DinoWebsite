/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/models/web3Ktx2.glb 
*/

import React, { useContext, useEffect, useLayoutEffect, useRef } from "react";
import { useGraph, useThree } from "@react-three/fiber";
import { useGLTF, PerspectiveCamera, useAnimations, Scroll } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import gsap from "gsap";
import { Observer } from "gsap/Observer";
import { ScrollTrigger } from "gsap/ScrollTrigger";
import * as THREE from "three";
import { AnimationContext } from "./AnimationContext";
import { KTX2Loader } from "three/examples/jsm/Addons.js";

export default function Web2({ sectionID, isActive, ...props }) {
  const gl = useThree((state) => state.gl);
  const group = React.useRef();
   const currentTween = useRef(null);
  const { scene, animations } = useGLTF("/models/Web2Final.glb",
    undefined,
    undefined,
    (loader) => {
      const ktx2loader = new KTX2Loader();
      ktx2loader.setTranscoderPath(
        "https://cdn.jsdelivr.net/gh/pmndrs/drei-assets/basis/"
      );
      ktx2loader.detectSupport(gl);
      loader.setKTX2Loader(ktx2loader);
    }
  );

  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);
  const { actions, mixer } = useAnimations(animations, group);
  const { setCurrentModel, isTransitioning, setIsTransitioning } =
    useContext(AnimationContext);
  const Animations = [
    "40M",
    "40MRope",
    "ArmatureMan",
    "BallonHotAirAction",
    "Balloon",
    "Balloon.001",
    "Balloon.002",
    "Emoji",
    "LeftHand",
    "RightHand",
  ];
  const smoothAnimations = ["Clouds1", "Clouds2"];
  let nextScrollTrigger = null;
  let prevScrollTrigger = null;
  let scrollDirection = 1;
  const sceneContainerGroup = useRef();
  let disableOtherSections = () => {
    if (!prevScrollTrigger) {
      let currentScrollTrigger = ScrollTrigger.getById(sectionID);
      if (currentScrollTrigger && currentScrollTrigger.previous()) {
        prevScrollTrigger = currentScrollTrigger.previous();
        prevScrollTrigger.disable();
      }
    } else {
      prevScrollTrigger.disable();
    }

    if (!nextScrollTrigger) {
      let currentScrollTrigger = ScrollTrigger.getById(sectionID);
      if (currentScrollTrigger && currentScrollTrigger.next()) {
        nextScrollTrigger = currentScrollTrigger.next();
        nextScrollTrigger.disable();
      }
    } else {
      nextScrollTrigger.disable();
    }
  }

  let enableOtherSections = () => {
    // use when scroll is too quick for transitions
    // this way any section t the end of the scroll could take control and disable the others
    ScrollTrigger.getAll().forEach((trigger) => {
      if (trigger.id !== sectionID) {
        trigger.enable();
      }
    })
  }

  let enterAnim = actions["ActionEnter"];
  let leaveAnim = actions["ActionOut"];
  let sceneDefaultPos = 0;

  // handling screen width change
  const { viewport } = useThree()
  const viewportRef = useRef(viewport);
  useEffect(() => {
    viewportRef.current = viewport;
  }, [viewport]);

useLayoutEffect(() => {
  enterAnim = actions["ActionEnter"];
  leaveAnim = actions["ActionOut"];
  sceneDefaultPos = sceneContainerGroup.current.position.y;

  // scroll tracking
  Observer.create({
    target: window,
    type: "wheel,touch,pointer,scroll",
    onChange: obs => {
      scrollDirection = obs.deltaY < 0 ? -1 : 1;
    }
  });

  const mm = gsap.matchMedia();

  // ✅ Desktop only
  mm.add("(min-width: 768px)", () => {
    const trigger = ScrollTrigger.create({
      id: sectionID,
      trigger: "#section3",
      start: "center+=100 bottom",
      end: "center+=100 top",
      scrub: true,
      markers: false,
      preventClicks: true,
      onToggle: self => {
        if (self.isActive) {
          disableOtherSections();
          playStaticAnimations();
          setCurrentModel(sectionID);

          if (scrollDirection >= 0) {
            // onEnter
            if (enterAnim) {
              enterAnim.reset().setLoop(THREE.LoopOnce, 1);
              enterAnim.clampWhenFinished = true;
              enterAnim.time = 0;
              enterAnim.timeScale = 1;
              enterAnim.play();
            }
            gsap.to(sceneContainerGroup.current.position, {
              y: sceneDefaultPos,
              duration: leaveAnim.getClip().duration,
              ease: "back.out"
            });
          } else {
            playOnEnterBackSequence();
          }
        } else {
          if (scrollDirection >= 0) {
            handleOnLeave(self);
          }
        }
      },
      onLeaveBack: (self) => {
        if (Math.abs(self.getVelocity()) <= 2000) {
          enterAnim.reset();
          enterAnim.setLoop(THREE.LoopOnce, 1);
          enterAnim.clampWhenFinished = true;
          enterAnim.time = enterAnim.getClip().duration;
          enterAnim.timeScale = -1.5;

          const onActionFinished = (event) => {
            if (event.action === enterAnim) {
              enterAnim.getMixer().removeEventListener("finished", onActionFinished);
              prevScrollTrigger.enable();
            }
          };

          enterAnim.getMixer().addEventListener("finished", onActionFinished);
          enterAnim.play();
        } else {
          
          enableOtherSections();
        }
      }
    });

    return () => trigger.kill();
  });

  // ✅ Mobile only (tu peux mettre autre comportement ici si besoin)
  mm.add("(max-width: 767px)", () => {
     // Ajustement mobile initial (si nécessaire)
  sceneContainerGroup.current.position.y -=1.7;
   sceneContainerGroup.current.position.z += 0.1;
    // Valeurs de référence pour animation
  const sceneDefaultPos = sceneContainerGroup.current.position.y;
  const minY = sceneDefaultPos;
  const maxY = sceneDefaultPos + 8; // ajuste selon la distance souhaitée
    const trigger = ScrollTrigger.create({
      id: sectionID + "-mobile",
      trigger: "#section3",
      start: "top bottom+=275",
      end: "bottom top",
      scrub: true,
      markers: false,
      preventClicks: true,
        onUpdate: (self) => {
      const progress = self.progress;
      const newY = THREE.MathUtils.lerp(minY, maxY, progress);

      if (currentTween.current) currentTween.current.kill();

      currentTween.current = gsap.to(sceneContainerGroup.current.position, {
        y: newY,
        duration: 0.3,
        ease: "sine.out",
        overwrite: true
      });
    },
      onToggle: self => {
        if (self.isActive) {
          disableOtherSections();
          playStaticAnimations();
          setCurrentModel(sectionID);

          if (scrollDirection >= 0) {
            // onEnter
            if (enterAnim) {
              enterAnim.reset().setLoop(THREE.LoopOnce, 1);
              enterAnim.clampWhenFinished = true;
              enterAnim.time = 0;
              enterAnim.timeScale = 1;
              enterAnim.play();
            }
            gsap.to(sceneContainerGroup.current.position, {
              y: sceneDefaultPos,
              duration: leaveAnim.getClip().duration,
              ease: "back.out"
            });
          } else {
            playOnEnterBackSequence();
          }
        } else {
          if (scrollDirection >= 0) {
            handleOnLeave(self);
          }
        }
      },
      onLeaveBack: (self) => {
        if (Math.abs(self.getVelocity()) <= 2000) {
          enterAnim.reset();
          enterAnim.setLoop(THREE.LoopOnce, 1);
          enterAnim.clampWhenFinished = true;
          enterAnim.time = enterAnim.getClip().duration;
          enterAnim.timeScale = -1.5;

          const onActionFinished = (event) => {
            if (event.action === enterAnim) {
              enterAnim.getMixer().removeEventListener("finished", onActionFinished);
              if(prevScrollTrigger){
                prevScrollTrigger.enable();
              }
              
            }
          };

          enterAnim.getMixer().addEventListener("finished", onActionFinished);
          enterAnim.play();
        } else {
          enableOtherSections();
        }
      }
    });

    return () => trigger.kill();
  });

  return () => {
    mm.revert();
    mixer.stopAllAction();
  };
}, []);


  let playOnEnterBackSequence = () => {
    if (leaveAnim) {
      leaveAnim.reset();
      leaveAnim.setLoop(THREE.LoopOnce, 1);
      leaveAnim.time = leaveAnim.getClip().duration;
      leaveAnim.timeScale = -1;
      leaveAnim.clampWhenFinished = true;
      leaveAnim.play();
    }
    gsap.to(sceneContainerGroup.current.position, {
      y: sceneDefaultPos,
      duration: leaveAnim.getClip().duration,
      ease: "back.out"
    });
  }

  let playStaticAnimations = () => {
    Animations.forEach((name) => {
      actions[name]?.reset().play();
    });

    smoothAnimations.forEach((name) => {
      actions[name]?.reset().setEffectiveTimeScale(0.2).play();
    });
  }

  let handleOnLeave = (self) => {
    if (Math.abs(self.getVelocity()) <= 4000) {
      if(nextScrollTrigger){
        nextScrollTrigger.disable();
      }
      
      // Reset & configure the action
      leaveAnim.reset().setLoop(THREE.LoopOnce, 1);
      leaveAnim.clampWhenFinished = true;
      leaveAnim.timeScale = 1;

      gsap.to(sceneContainerGroup.current.position, {
        y: sceneDefaultPos + 10,
        duration: leaveAnim.getClip().duration,
        ease: "back.in"
      });

      setTimeout(() => {
         if(nextScrollTrigger){
        nextScrollTrigger.enable();
         }
      }, leaveAnim.getClip().duration * 1000 * leaveAnim.timeScale);
      leaveAnim.play();
    } else {
      enableOtherSections();
    }
  }

  return (
    <group ref={group} {...props} dispose={null} visible={isActive}>
      <group name="Scene">
        <group name="Empty001" position={[23.142, 1.679, 1.408]} scale={0.15}>
          <PerspectiveCamera
            name="Camera"
            makeDefault={isActive}
            far={1000}
            near={0.1}
            fov={16.696}
            position={[0, 0.151, 0.577]}
            rotation={[0, 1.571, 0]}
            scale={6.678}
          />
        </group>
        <group ref={sceneContainerGroup} name="scene_container"
          scale={viewport.width < 5 ? 0.7 : 1}
          // position-x={viewport.width < 5 ? 2.5 : 0}
          position-z={viewport.width < 5 ? 1.5 : 0}
          position-y={viewport.width < 5 ? 0.3 : 0}
        >

          <mesh
            name="Sphere014"
            castShadow
            receiveShadow
            geometry={nodes.Sphere014.geometry}
            material={nodes.Sphere014.material}
            position={[-3.668, 4.08, -2.876]}
            scale={[0.45, 0.767, 0.767]}
          />
          <mesh
            name="Sphere001"
            castShadow
            receiveShadow
            geometry={nodes.Sphere001.geometry}
            material={nodes.Sphere001.material}
            position={[-3.668, 12.438, 2.018]}
            rotation={[Math.PI, 0, Math.PI]}
            scale={[0.45, 0.767, 0.767]}
          />
          <mesh
            name="Sphere002"
            castShadow
            receiveShadow
            geometry={nodes.Sphere002.geometry}
            material={materials.PaletteMaterial001}
            position={[-0.212, -0.265, -3.618]}
            rotation={[-0.413, 0.743, 0.652]}
            scale={0.68}
          />
          <group
            name="BallonHotAir"
            position={[-14.582, 4.564, 2.476]}
            rotation={[0.007, -0.012, -0.001]}
            scale={0.694}>
            <mesh
              name="Sphere010"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010.geometry}
              material={materials.PaletteMaterial001}
            />
            <mesh
              name="Sphere010_1"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010_1.geometry}
              material={materials.PaletteMaterial001}
            />
            <mesh
              name="Sphere010_2"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010_2.geometry}
              material={materials.PaletteMaterial001}
            />
            <mesh
              name="Sphere010_3"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010_3.geometry}
              material={materials.PaletteMaterial001}
            />
            <mesh
              name="Sphere010_4"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010_4.geometry}
              material={materials.PaletteMaterial001}
            />
            <mesh
              name="Sphere010_5"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010_5.geometry}
              material={materials.PaletteMaterial001}
            />
            <mesh
              name="Sphere010_6"
              castShadow
              receiveShadow
              geometry={nodes.Sphere010_6.geometry}
              material={materials.PaletteMaterial001}
            />
          </group>
          <group
            name="Cube043_Cube053"
            position={[2.297, -5.768, -1.96]}
            rotation={[Math.PI / 2, 0, 0]}>
            <mesh
              name="Cube043_Cube053_1"
              castShadow
              receiveShadow
              geometry={nodes.Cube043_Cube053_1.geometry}
              material={materials.PaletteMaterial003}
            />
            <mesh
              name="Cube043_Cube053_2"
              castShadow
              receiveShadow
              geometry={nodes.Cube043_Cube053_2.geometry}
              material={materials.PaletteMaterial001}
            />
          </group>
          <group
            name="Cube044_Cube054"
            position={[-6.655, -4.081, 0.819]}
            rotation={[Math.PI / 2, 0, -1.594]}>
            <mesh
              name="Cube044_Cube054_1"
              castShadow
              receiveShadow
              geometry={nodes.Cube044_Cube054_1.geometry}
              material={materials.PaletteMaterial003}
            />
            <mesh
              name="Cube044_Cube054_2"
              castShadow
              receiveShadow
              geometry={nodes.Cube044_Cube054_2.geometry}
              material={materials.PaletteMaterial001}
            />
          </group>
          <group
            name="Cube043_Cube001"
            position={[2.099, -7.888, 3.968]}
            rotation={[Math.PI / 2, 0, 0]}>
            <mesh
              name="Cube043_Cube001_1"
              castShadow
              receiveShadow
              geometry={nodes.Cube043_Cube001_1.geometry}
              material={materials.PaletteMaterial003}
            />
            <mesh
              name="Cube043_Cube001_2"
              castShadow
              receiveShadow
              geometry={nodes.Cube043_Cube001_2.geometry}
              material={materials.PaletteMaterial001}
            />
          </group>
          <group
            name="Armature001"
            position={[-0.091, 0.84, -0.237]}
            rotation={[0.077, 1.536, -0.317]}
            scale={0.336}>
            <primitive object={nodes.Bone} />
            <primitive object={nodes.Bone007} />
            <primitive object={nodes.Bone008} />
          </group>
          <group
            name="Empty005"
            position={[0.004, 1.693, -0.583]}
            rotation={[1.528, 1.519, -0.667]}
            scale={1.047}>
            <mesh
              name="Trophy"
              castShadow
              receiveShadow
              geometry={nodes.Trophy.geometry}
              material={materials.PaletteMaterial001}
              position={[0.357, -0.012, 0.013]}
              rotation={[1.425, -1.328, 1.432]}
              scale={0.955}
            />
          </group>
          <group
            name="Empty006"
            position={[-0.072, 1.82, 0.182]}
            rotation={[0.831, 1.513, -0.007]}
            scale={0.268}>
            <group
              name="Armature"
              position={[0.239, 0.054, 0.33]}
              rotation={[1.601, 0.618, 1.507]}
              scale={3.568}>
              <skinnedMesh
                name="Cube"
                geometry={nodes.Cube.geometry}
                material={materials.PaletteMaterial001}
                skeleton={nodes.Cube.skeleton}
              />
              <primitive object={nodes.Bone_1} />
            </group>
            <mesh
              name="Cube001"
              castShadow
              receiveShadow
              geometry={nodes.Cube001.geometry}
              material={materials.PaletteMaterial001}
              position={[-0.12, -0.118, 0.312]}
              rotation={[-1.58, 0.644, 1.602]}
              scale={3.568}
            />
            <group
              name="Cube011"
              position={[0.321, 0.089, 0.383]}
              rotation={[1.581, 0.176, -1.628]}
              scale={[0.076, 2.381, 0.076]}>
              <mesh
                name="Cube019"
                castShadow
                receiveShadow
                geometry={nodes.Cube019.geometry}
                material={materials.PaletteMaterial001}
              />
              <mesh
                name="Cube019_1"
                castShadow
                receiveShadow
                geometry={nodes.Cube019_1.geometry}
                material={materials.PaletteMaterial001}
              />
            </group>
          </group>
          <mesh
            name="Mouth_Cube002"
            castShadow
            receiveShadow
            geometry={nodes.Mouth_Cube002.geometry}
            material={materials.PaletteMaterial002}
            position={[0.341, -0.418, -3.247]}
            rotation={[1.635, 0.463, -0.857]}
            scale={0.292}
          />
          <group
            name="Retopo_Sphere001"
            position={[-0.091, 0.84, -0.237]}
            rotation={[0.077, 1.536, -0.317]}
            scale={0.336}>
            <skinnedMesh
              name="mesh001"
              geometry={nodes.mesh001.geometry}
              material={materials.PaletteMaterial001}
              skeleton={nodes.mesh001.skeleton}
            />
            <skinnedMesh
              name="mesh001_1"
              geometry={nodes.mesh001_1.geometry}
              material={materials.PaletteMaterial001}
              skeleton={nodes.mesh001_1.skeleton}
            />
            <skinnedMesh
              name="mesh001_2"
              geometry={nodes.mesh001_2.geometry}
              material={materials.PaletteMaterial001}
              skeleton={nodes.mesh001_2.skeleton}
            />
          </group>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("./models/Web2Final.glb");
